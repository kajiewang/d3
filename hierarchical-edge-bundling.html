<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css">
    <script src="https://d3js.org/d3.v6.min.js"></script>

    <title>d3 Examples</title>
</head>
<body>

<header>
    <div class="container">
        <div class="row">
            <div class="col-md-2">
                <img src="resources/d3logo.png">
            </div>
            <div class="col-md-10">
                <h1 class="logo">D3 Examples</h1>
                <h4>Richard Dalton</h4>
                <div class="btn-group btn-group-md" role="group" aria-label="...">
                    <a href="index.html" class="btn btn-default" role="button">Home</a>
                    <a href="barChart.html" class="btn btn-default" role="button">Bar</a>
                    <a href="http://www.d3js.org" class="btn btn-default" role="button">D3.js</a>
                </div>
            </div>
        </div>
    </div>
</header>


<div class="container">
    <h3>Bar Chart</h3>
    <p>We can draw a bar chart by using svg to render a rectangle of the appropriate size for each datapoint.</p>
    <p>In this example, we also use a D3 logarithmic scale, to map the domain of values 5-1300 to the range of
        bar heights 0-500.</p>

    <div class="col-md-6">
        <div id="draw_here"></div>
    </div>

    <div class="col-md-6">
<pre>


</pre>
    </div>
</div>

<script type="text/javascript">

    let getDataForId = function (id, data) {
        let fromData = data.filter(x => x.fromId == id)
        let toData = data.filter(x => x.toId == id)

        if (fromData.length < 1) {
            return { "jobTitle" : toData[0].toJobtitle, "email" : toData[0].toEmail}
        } else {
            return { "jobTitle" : fromData[0].fromJobtitle, "email" : fromData[0].fromEmail}
        }

    }

    fetch("./data.json")
        .then(response => {
            return response.json();
        })
        .then(data => {


            /* Get unique Ids */
            let uniqueFromIds = Array.from(new Set(data.map(({fromId}) => fromId)));
            let uniqueToIds = Array.from(new Set(data.map(({toId}) => toId)));
            let uniqueIds = Array.from(new Set(uniqueToIds.concat(uniqueFromIds)))



            /* Unique Data for each Id  */
            var dataset = uniqueIds.map(id => {



                let setOfRelevantDataPre = getDataForId(id,data)
                let setOfRelevantData = data.filter(x => x.fromId == id && x.toId != id)
                let setOfUniqueToIds = Array.from(new Set(setOfRelevantData.map(({toId}) => toId)));

                let uniqueSentList = setOfUniqueToIds.map(toId => "flare:" + setOfRelevantData.find(x => x.toId == toId).toJobtitle + ":" + setOfRelevantData.find(x => x.toId == toId).toEmail)

                return {
                    name: "flare:" + setOfRelevantDataPre.jobTitle +  ":" + setOfRelevantDataPre.email,
                    imports: uniqueSentList,
                    size: setOfRelevantData.length
                }


            });

            downloadObject(dataset,'data-formatted.json')
        })

    function downloadObject(obj, filename){
        var blob = new Blob([JSON.stringify(obj, null, 2)], {type: "application/json;charset=utf-8"}).slice(2,-1);
        var url = URL.createObjectURL(blob);
        var elem = document.createElement("a");
        elem.href = url;
        elem.download = filename;
        document.body.appendChild(elem);
        elem.click();
        document.body.removeChild(elem);
    }
</script>

<script type="module">
    import {Runtime, Inspector} from "./runtime.js";
    export default function define(runtime, observer) {
        const main = runtime.module();
        //const fileName = './flare.json'
        const fileName = './data-formatted.json'
        //const globalDelimiter = "."
        const globalDelimiter = ":"
        const fileAttachments = new Map([[fileName,new URL("./files/9b6806e3dd9c4c2c26760ba784437138c78b43a9a8e58a0bbafe5833026e3265637c9c7810224d66b79ba907b4d0be731c1a81ad043e10376aec3c18a49f3d84",import.meta.url)]]);
        main.builtin("FileAttachment", runtime.fileAttachments(name => fileAttachments.get(name)));
        main.variable(observer()).define(["md","colorout","colorin"], function(md,colorout,colorin){return(
            md`# Hierarchical Edge Bundling

This chart shows relationships among classes in a software hierarchy. Hover a class to reveal its imports (<b style="color: ${colorout};">outgoing</b> edges) and classes that import it (<b style="color: ${colorin};">incoming</b> edges).`
        )});
        main.variable(observer("chart")).define("chart", ["tree","bilink","d3","data","width","id","colornone","line","colorin","colorout"], function(tree,bilink,d3,data,width,id,colornone,line,colorin,colorout)
            {
                const root = tree(bilink(d3.hierarchy(data)
                    .sort((a, b) => d3.ascending(a.height, b.height) || d3.ascending(a.data.name, b.data.name))));

                const svg = d3.create("svg")
                    .attr("viewBox", [-width / 2, -width / 2, width, width]);

                const node = svg.append("g")
                    .attr("font-family", "sans-serif")
                    .attr("font-size", 10)
                    .selectAll("g")
                    .data(root.leaves())
                    .join("g")
                    .attr("transform", d => `rotate(${d.x * 180 / Math.PI - 90}) translate(${d.y},0)`)
                    .append("text")
                    .attr("dy", "0.31em")
                    .attr("x", d => d.x < Math.PI ? 6 : -6)
                    .attr("text-anchor", d => d.x < Math.PI ? "start" : "end")
                    .attr("transform", d => d.x >= Math.PI ? "rotate(180)" : null)
                    .text(d => d.data.name)
                    .each(function(d) { d.text = this; })
                    .on("mouseover", overed)
                    .on("mouseout", outed)
                    .call(text => text.append("title").text(d => `${id(d)}
${d.outgoing.length} sent to List`));

                const link = svg.append("g")
                    .attr("stroke", colornone)
                    .attr("fill", "none")
                    .selectAll("path")
                    .data(root.leaves().flatMap(leaf => leaf.outgoing))
                    .join("path")
                    .style("mix-blend-mode", "multiply")
                    .attr("d", ([i, o]) => line(i.path(o)))
                    .each(function(d) { d.path = this; });


                function overed(event, d) {
                    link.style("mix-blend-mode", null);
                    d3.select(this).attr("font-weight", "bold");
                    d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", colorout).raise();
                    d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("fill", colorout).attr("font-weight", "bold");
                }

                function outed(event, d) {
                    link.style("mix-blend-mode", "multiply");
                    d3.select(this).attr("font-weight", null);
                    d3.selectAll(d.outgoing.map(d => d.path)).attr("stroke", null);
                    d3.selectAll(d.outgoing.map(([, d]) => d.text)).attr("fill", null).attr("font-weight", null);
                }

                return svg.node();
            }
        );
        main.variable(observer("data")).define("data", ["hierarchy","FileAttachment"], async function(hierarchy,FileAttachment){return(
            hierarchy(await FileAttachment(fileName).json())
        )});
        main.variable(observer("hierarchy")).define("hierarchy", function(){return(
            function hierarchy(data, delimiter = globalDelimiter) {
                let root;
                const map = new Map;
                data.forEach(function find(data) {
                    const {name} = data;
                    if (map.has(name)) return map.get(name);
                    const i = name.lastIndexOf(delimiter);
                    map.set(name, data);
                    if (i >= 0) {
                        find({name: name.substring(0, i), children: []}).children.push(data);
                        data.name = name.substring(i + 1);
                    } else {
                        root = data;
                    }
                    return data;
                });
                return root;
            }
        )});
        main.variable(observer("bilink")).define("bilink", ["id"], function(id){return(
            function bilink(root) {
                const map = new Map(root.leaves().map(d => {
                    return [id(d), d]
                 }))
                for (const d of root.leaves()) {
                    d.incoming = []
                    d.outgoing = d.data.imports.map(i => {
                        return [d, map.get(i)]
                    });
                }

                for (const d of root.leaves()) {
                    for (const o of d.outgoing) {
                        o[1].incoming.push(o);
                    }
                }
                return root;
            }
        )});
        main.variable(observer("id")).define("id", function(){return(
            function id(node) {
                return `${node.parent ? id(node.parent) + globalDelimiter : ""}${node.data.name}`;
            }
        )});
        main.variable(observer("colorin")).define("colorin", function(){return(
            "#00f"
        )});
        main.variable(observer("colorout")).define("colorout", function(){return(
            "#f00"
        )});
        main.variable(observer("colornone")).define("colornone", function(){return(
            "#ccc"
        )});
        main.variable(observer("width")).define("width", function(){return(
            1000
        )});
        main.variable(observer("radius")).define("radius", ["width"], function(width){return(
            width / 2
        )});
        main.variable(observer("line")).define("line", ["d3"], function(d3){return(
            d3.lineRadial()
                .curve(d3.curveBundle.beta(0.85))
                .radius(d => d.y)
                .angle(d => d.x)
        )});
        main.variable(observer("tree")).define("tree", ["d3","radius"], function(d3,radius){return(
            d3.cluster()
                .size([2 * Math.PI, radius - 100])
        )});
        main.variable(observer("d3")).define("d3", ["require"], function(require){return(
            require("d3@6")
        )});
        return main;
    }

    const runtime = new Runtime();
    const main = runtime.module(define, Inspector.into(document.body));


</script>










</body>

</html>
